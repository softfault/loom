[Animal]
# [Fix] 父类定义契约，最好显式写出类型
name: str = "Unknown"

speak = () 
    print("...")

introduce = () 
    print("I am an Animal")

[Dog : Animal]
# [Fix] 子类必须显式履行契约
# 加上 `: str` 告诉 Analyzer："我明确知道我要覆盖父类的 str 字段"
# 否则 Analyzer 看到的类型是 `Infer` (即 `_`)，它不等于 `str`，于是报错
name: str = "Doggy"

# 方法覆盖也同理，保持签名完全一致
speak = () 
    print("Woof! Woof!")

# Loom 的 "Pre-fill" 机制会自动把 Animal.introduce 复制给 Dog
# 所以这里不需要写 introduce，但调用时 Dog 会有这个方法

[Main]
main = () int
    d = Dog()
    
    # 1. 测试字段覆盖
    print("Name: " + d.name)  
    
    # 2. 测试方法覆盖
    d.speak()
    
    # 3. 测试方法继承 (Pre-fill)
    # 你的 Interpreter 需要去查找父类的方法或者 Analyzer 已经把它填进了 Dog 的定义里
    d.introduce()
    
    return 0